# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.12
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_pystare')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_pystare')
    _pystare = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_pystare', [dirname(__file__)])
        except ImportError:
            import _pystare
            return _pystare
        try:
            _mod = imp.load_module('_pystare', fp, pathname, description)
        finally:
            if fp is not None:
                fp.close()
        return _mod
    _pystare = swig_import_helper()
    del swig_import_helper
else:
    import _pystare
del _swig_python_version_info

try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0


import numpy

class PyStareError(Exception):
    pass

class PyStareArrayBoundsExceeded(Exception):
    pass

def to_neighbors(indices):
    out_length = 12*len(indices)
    len_ri = 0
    range_indices = numpy.full([out_length],-1,dtype=numpy.int64)
    _to_neighbors(indices,range_indices)
    endarg = 0
    while ( endarg < out_length ) and (range_indices[endarg] > 0 ) :
        endarg = endarg + 1
    range_indices = range_indices[:endarg]
    return range_indices

def to_compressed_range(indices):
    out_length = len(indices)
    range_indices = numpy.full([out_length],-1,dtype=numpy.int64)
    len_ri = 0
    _to_compressed_range(indices,range_indices)
    endarg = 0
    while (endarg < out_length) and (range_indices[endarg] > 0):
      endarg = endarg + 1
# endarg = numpy.argmax(range_indices < 0)
    range_indices = range_indices[:endarg]
    return range_indices

def expand_intervals(intervals, resolution, result_size_limit=1000):
	result      = numpy.full([result_size_limit],-1,dtype=numpy.int64)
	result_size = numpy.full([1],-1,dtype=numpy.int64)
	_expand_intervals(intervals,resolution,result,result_size)
	result = result[:result_size[0]]
	return result

def to_hull_range(indices, resolution, range_size_limit=1000):
    out_length = range_size_limit
    range_indices = numpy.full([out_length], -1, dtype=numpy.int64)
    result_size = numpy.full([1], -1, dtype=numpy.int64)
    _to_hull_range(indices, resolution, range_indices,result_size)
    range_indices = range_indices[:result_size[0]]
    return range_indices

def to_hull_range_from_latlon(lat, lon, resolution, range_size_limit=1000):
    out_length = range_size_limit
    range_indices = numpy.full([out_length], -1, dtype=numpy.int64)
    result_size = numpy.full([1], -1, dtype=numpy.int64)
    _to_hull_range_from_latlon(lat, lon, resolution, range_indices, result_size)
    range_indices = range_indices[:result_size[0]]
    return range_indices

# def to_circular_cover(lat, lon, radius, resolution, range_size_limit=1000):
#     out_length = range_size_limit
#     range_indices = numpy.full([out_length],-1,dtype=numpy.int64)
#     result_size = numpy.full([1],-1,dtype=numpy.int64)
#     _to_circular_cover(lat,lon,radius,resolution,range_indices,result_size)
#     range_indices = range_indices[:result_size[0]]
#     return range_indices

def to_circular_cover(lat, lon, radius, resolution):
    result = _to_circular_cover1(lat, lon, radius, resolution)
    out_length = result.get_size_as_intervals()
    range_indices = numpy.zeros([out_length],dtype=numpy.int64)
    result.copy_as_intervals(range_indices);
    return range_indices

def to_vertices_latlon(indices):
	out_length = len(indices)
	lats = numpy.zeros([4*out_length],dtype=numpy.double)
	lons = numpy.zeros([4*out_length],dtype=numpy.double)
# _to_vertices_latlon(indices,lats,lons,0)
	lats, lons = _to_vertices_latlon(indices)
	latsv = numpy.zeros([3*out_length],dtype=numpy.double)
	lonsv = numpy.zeros([3*out_length],dtype=numpy.double)
	lat_center = numpy.zeros([out_length],dtype=numpy.double)
	lon_center = numpy.zeros([out_length],dtype=numpy.double)

	k=0
	l=0
	for i in range(out_length):
		latsv[l]   = lats[ k   ]
		lonsv[l]   = lons[ k   ]

		latsv[l+1] = lats[ k+1 ]
		lonsv[l+1] = lons[ k+1 ]

		latsv[l+2] = lats[ k+2 ]
		lonsv[l+2] = lons[ k+2 ]

		lat_center [i]   = lats[ k+3 ]
		lon_center [i]   = lons[ k+3 ]
		k = k + 4
		l = l + 3
	return latsv,lonsv,lat_center,lon_center

def cmp_spatial(indices1, indices2):
	out_length = len(indices1)*len(indices2)
	cmp = numpy.zeros([out_length],dtype=numpy.int64)
	_cmp_spatial(indices1,indices2,cmp)
	return cmp

def cmp_temporal(indices1, indices2):
	out_length = len(indices1)*len(indices2)
	cmp = numpy.zeros([out_length],dtype=numpy.int64)
	_cmp_temporal(indices1,indices2,cmp)
	return cmp   

def intersect(indices1, indices2, multiresolution=True):
    out_length = 2*max(len(indices1), len(indices2))
    intersected = numpy.full([out_length], -1, dtype=numpy.int64)
    leni = 0
    if(multiresolution):
      _intersect_multiresolution(indices1, indices2, intersected)
    else:
      _intersect(indices1, indices2, intersected)
    endarg = numpy.argmax(intersected < 0)
    intersected = intersected[:endarg]
    return intersected

def shiftarg_lon(lon):
    "If lon is outside +/-180, then correct back."
    if(lon>180):
        return ((lon + 180.0) % 360.0)-180.0
    else:
        return lon

def shiftarg_lat(lat):
    "If lat is outside +/-90, then correct back."
    if(lat>90):
        return ((lat + 90.0) % 180.0)-90.0
    else:
        return lat

def spatial_resolution(km):
    return 10-np.log2(km/10)

def triangulate(lats,lons):
    "Help prepare data for matplotlib.tri.Triangulate."
    intmat=[]
    npts=int(len(lats)/3)
    k=0
    for i in range(npts):
        intmat.append([k,k+1,k+2])
        k=k+3
    for i in range(len(lons)):
        lons[i] = shiftarg_lon(lons[i])
# print('triangulating1 done.')      
    return lons,lats,intmat 

def triangulate_indices(indices):
    """ Prepare data for matplotlib.tri.Triangulate."""

    lons,lats,intmat = triangulate_indices(indices)
    triang = tri.Triangulation(lons,lats,intmat)
    plt.triplot(triang,'r-',transform=transform,lw=1,markersize=3)
    latv,lonv,lat_center,lon_center = to_vertices_latlon(indices)
    lons,lats,intmat = triangulate(latv,lonv)
    return lons,lats,intmat


# Shapely integration 

import shapely.geometry

def from_shapely(geom, resolution):
    if geom.geom_type == 'Point':
        return from_point(geom, resolution)
    if geom.geom_type == 'Polygon':
        return from_polygon(geom)

def from_point(point, resolution):
    lat = point.y
    lon = point.x
    index_value = from_latlon([lat], [lon], resolution)
    return index_value

def from_polygon(polygon, resolution=-1, range_size_limit=1000):
    latlon = polygon.exterior.coords.xy
    lon = latlon[0]
    lat = latlon[1]
    range_indices = to_hull_range_from_latlon(lat, lon, resolution, range_size_limit)
    return range_indices

def from_multipolygon(multipolygon, resolution=-1, range_size_limit=1000):
    range_indices = []
    for polygon in multipolygon.geoms:
        range_indices += list(from_polygon(polygon, resolution, range_size_limit))
    return range_indices

# Geopandas integration
import geopandas

def from_geopandas(gdf, resolution=-1, range_size_limit=1000):
# Test if all geometries are Points or Polygons
    if set(gdf.geom_type) == {'Point'}:
        lat = gdf.geometry.y
        lon = gdf.geometry.x
        return from_latlon(lat, lon, resolution)
    if not set(gdf.geom_type) - {'Polygon', 'MultiPolygon'}:
        index_values = []
        for polygon in gdf.geometry:
            if polygon.type == 'Polygon':
                index_values.append(from_polygon(polygon, resolution, range_size_limit))
            else:
                index_values.append(from_multipolygon(polygon, resolution, range_size_limit))
        return index_values        
    else:
        print('inhomogenous geometry types')
        return 1

def to_trixels_series(series):
    trixels_series = []
    for index_values in series:
        trixels = to_trixels(index_values)
        trixels = shapely.geometry.MultiPolygon(trixels)
        trixels_series.append(trixels)
    return trixels_series

def to_trixels(indices):
    latv, lonv = _to_vertices_latlon(indices)
    for i in range(len(latv)):
        latv[i] = shiftarg_lat(latv[i])
        lonv[i] = shiftarg_lon(lonv[i])
    i = 0    
    trixels = []
    while i < len(latv):
        geom = shapely.geometry.Polygon([[lonv[i], latv[i]], [lonv[i+1], latv[i+1]], [lonv[i+2], latv[i+2]]])
        trixels.append(geom)
        i += 4
    return trixels



def from_latlon(lat, lon, level):
    return _pystare.from_latlon(lat, lon, level)
from_latlon = _pystare.from_latlon

def to_latlon(indices):
    return _pystare.to_latlon(indices)
to_latlon = _pystare.to_latlon

def to_latlonlevel(indices):
    return _pystare.to_latlonlevel(indices)
to_latlonlevel = _pystare.to_latlonlevel

def to_level(indices):
    return _pystare.to_level(indices)
to_level = _pystare.to_level

def _to_vertices_latlon(indices):
    return _pystare._to_vertices_latlon(indices)
_to_vertices_latlon = _pystare._to_vertices_latlon

def to_area(indices):
    return _pystare.to_area(indices)
to_area = _pystare.to_area

def _to_neighbors(indices, range_indices):
    return _pystare._to_neighbors(indices, range_indices)
_to_neighbors = _pystare._to_neighbors

def _to_compressed_range(indices, range_indices):
    return _pystare._to_compressed_range(indices, range_indices)
_to_compressed_range = _pystare._to_compressed_range

def _to_hull_range(indices, resolution, range_indices, result_size):
    return _pystare._to_hull_range(indices, resolution, range_indices, result_size)
_to_hull_range = _pystare._to_hull_range

def _expand_intervals(indices, resolution, range_indices, result_size):
    return _pystare._expand_intervals(indices, resolution, range_indices, result_size)
_expand_intervals = _pystare._expand_intervals

def _to_hull_range_from_latlon(lat, lon, resolution, range_indices, result_size):
    return _pystare._to_hull_range_from_latlon(lat, lon, resolution, range_indices, result_size)
_to_hull_range_from_latlon = _pystare._to_hull_range_from_latlon

def _to_circular_cover(lat, lon, radius, resolution, range_indices, result_size):
    return _pystare._to_circular_cover(lat, lon, radius, resolution, range_indices, result_size)
_to_circular_cover = _pystare._to_circular_cover

def from_intervals(intervals):
    return _pystare.from_intervals(intervals)
from_intervals = _pystare.from_intervals

def _intersect(indices1, indices2, intersection):
    return _pystare._intersect(indices1, indices2, intersection)
_intersect = _pystare._intersect

def _intersect_multiresolution(indices1, indices2, intersection):
    return _pystare._intersect_multiresolution(indices1, indices2, intersection)
_intersect_multiresolution = _pystare._intersect_multiresolution

def _cmp_spatial(indices1, indices2, cmp):
    return _pystare._cmp_spatial(indices1, indices2, cmp)
_cmp_spatial = _pystare._cmp_spatial

def _intersects(indices1, indices2):
    return _pystare._intersects(indices1, indices2)
_intersects = _pystare._intersects

def from_utc(datetime, resolution):
    return _pystare.from_utc(datetime, resolution)
from_utc = _pystare.from_utc

def to_utc_approximate(indices):
    return _pystare.to_utc_approximate(indices)
to_utc_approximate = _pystare.to_utc_approximate

def _cmp_temporal(indices1, indices2, cmp):
    return _pystare._cmp_temporal(indices1, indices2, cmp)
_cmp_temporal = _pystare._cmp_temporal
SpatialIntervals = _pystare.SpatialIntervals
ArrayIndexSpatialValues = _pystare.ArrayIndexSpatialValues
class StareResult(_object):
    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, StareResult, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, StareResult, name)
    __repr__ = _swig_repr

    def __init__(self):
        this = _pystare.new_StareResult()
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this

    def add_intervals(self, sis):
        return _pystare.StareResult_add_intervals(self, sis)

    def add_indexValues(self, sisvs):
        return _pystare.StareResult_add_indexValues(self, sisvs)
    __swig_destroy__ = _pystare.delete_StareResult
    __del__ = lambda self: None

    def get_size(self):
        return _pystare.StareResult_get_size(self)

    def get_size_as_values(self):
        return _pystare.StareResult_get_size_as_values(self)

    def get_size_as_intervals(self):
        return _pystare.StareResult_get_size_as_intervals(self)

    def copy(self, indices):
        return _pystare.StareResult_copy(self, indices)

    def copy_as_values(self, indices):
        return _pystare.StareResult_copy_as_values(self, indices)

    def copy_as_intervals(self, indices):
        return _pystare.StareResult_copy_as_intervals(self, indices)

    def convert(self):
        return _pystare.StareResult_convert(self)
    __swig_setmethods__["converted"] = _pystare.StareResult_converted_set
    __swig_getmethods__["converted"] = _pystare.StareResult_converted_get
    if _newclass:
        converted = _swig_property(_pystare.StareResult_converted_get, _pystare.StareResult_converted_set)
    __swig_setmethods__["sis"] = _pystare.StareResult_sis_set
    __swig_getmethods__["sis"] = _pystare.StareResult_sis_get
    if _newclass:
        sis = _swig_property(_pystare.StareResult_sis_get, _pystare.StareResult_sis_set)
    __swig_setmethods__["sisvs"] = _pystare.StareResult_sisvs_set
    __swig_getmethods__["sisvs"] = _pystare.StareResult_sisvs_get
    if _newclass:
        sisvs = _swig_property(_pystare.StareResult_sisvs_get, _pystare.StareResult_sisvs_set)
    __swig_setmethods__["sCase"] = _pystare.StareResult_sCase_set
    __swig_getmethods__["sCase"] = _pystare.StareResult_sCase_get
    if _newclass:
        sCase = _swig_property(_pystare.StareResult_sCase_get, _pystare.StareResult_sCase_set)
StareResult_swigregister = _pystare.StareResult_swigregister
StareResult_swigregister(StareResult)
cvar = _pystare.cvar


def _to_circular_cover1(lat, lon, radius, resolution):
    return _pystare._to_circular_cover1(lat, lon, radius, resolution)
_to_circular_cover1 = _pystare._to_circular_cover1
# This file is compatible with both classic and new-style classes.


